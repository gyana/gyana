# Generated by Django 3.2.12 on 2022-03-31 10:18

from datetime import datetime

import requests
from django.conf import settings
from django.db import migrations, models

group_url = (
    f"{settings.FIVETRAN_URL}/groups/{settings.FIVETRAN_GROUP}/connectors?limit=1000"
)


def parse_fivetran_timestamp(timestamp):
    if timestamp is not None:
        return datetime.strptime(timestamp, "%Y-%m-%dT%H:%M:%S.%f%z")


def update_kwargs_from_fivetran(connector, data):
    status = data["status"]

    kwargs = {
        "fivetran_id": data["id"],
        "group_id": data["group_id"],
        "service": data["service"],
        "service_version": data["service_version"],
        "schema": data["schema"],
        "paused": data["paused"],
        "pause_after_trial": data["pause_after_trial"],
        "connected_by": data["connected_by"],
        "created_at": parse_fivetran_timestamp(data["created_at"]),
        "succeeded_at": parse_fivetran_timestamp(data["succeeded_at"]),
        "failed_at": parse_fivetran_timestamp(data["failed_at"]),
        "sync_frequency": data["sync_frequency"],
        "daily_sync_time": data.get("daily_sync_time"),
        "schedule_type": data["schedule_type"],
        "setup_state": status["setup_state"],
        "sync_state": status["sync_state"],
        "update_state": status["update_state"],
        "is_historical_sync": status["is_historical_sync"],
        "tasks": status["tasks"],
        "warnings": status["warnings"],
        "source_sync_details": data.get("source_sync_details"),
    }

    for key, value in kwargs.items():
        setattr(connector, key, value)

    # only available for individual connector get (not group list)
    if "config" in data and data["config"] is not None:
        connector.config = data["config"]


def forward(apps, schema_editor):
    Connector = apps.get_model("connectors", "Connector")
    Integration = apps.get_model("integrations", "Integration")

    connectors = requests.get(group_url, headers=settings.FIVETRAN_HEADERS).json()[
        "data"
    ]["items"]

    google_ads = list(filter(lambda c: c["service"] == "adwords", connectors))

    schema_mapping = {c["schema"]: c for c in google_ads}

    for c in google_ads:
        if new_c := schema_mapping.get(f"{c['schema']}_new_api"):
            if old_connector := Connector.objects.filter(fivetran_id=c["id"]).first():
                old_integration = old_connector.integration

                new_integration = Integration.objects.create(
                    project=old_integration.project,
                    kind="connector",
                    name=f"{old_integration.name} New Api",
                    created_by=old_integration.created_by,
                    is_scheduled=old_integration.is_scheduled,
                    state="load",
                    ready=False,
                )
                new_connector = Connector(integration=new_integration)
                update_kwargs_from_fivetran(new_connector, new_c)
                new_connector.save()

                old_connector.sync_state = "sunset"
                old_connector.paused = True
                old_connector.save()


class Migration(migrations.Migration):

    dependencies = [
        ("connectors", "0020_alter_connector_fivetran_id"),
    ]

    operations = [
        migrations.AlterField(
            model_name="connector",
            name="sync_state",
            field=models.CharField(
                choices=[
                    ("scheduled", "Scheduled - the sync is waiting to be run"),
                    ("syncing", "Syncing - the sync is currently running"),
                    ("paused", "Paused - the sync is currently paused"),
                    (
                        "rescheduled",
                        "Rescheduled - the sync is waiting until more API calls are available in the source service",
                    ),
                    (
                        "sunset",
                        "Sunset - this connector is no longer supported and won't sync.",
                    ),
                ],
                max_length=16,
            ),
        ),
        migrations.RunPython(forward, reverse_code=migrations.RunPython.noop),
    ]
